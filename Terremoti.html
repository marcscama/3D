<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Visualizzatore Terremoti</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    #fileInput {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <!-- Input per caricare il file CSV -->
  <input type="file" id="fileInput" accept=".csv" />

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/controls/OrbitControls.js';

    // Inizializza scena, camera e renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Posizione della camera
    camera.position.set(0, 0, 10000);

    // Controlli della camera (OrbitControls)
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; // Migliora la fluiditÃ  del movimento

    // Luce
    const light = new THREE.PointLight(0xffffff, 1);
    light.position.set(5000, 5000, 10000);
    scene.add(light);

    // Riferimento all'input file
    const fileInput = document.getElementById('fileInput');
    fileInput.addEventListener('change', handleFile);

    function handleFile(event) {
      const file = event.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function (e) {
          const text = e.target.result;
          loadCSVData(text);
        };
        reader.readAsText(file);
      }
    }

    // Funzione per caricare e visualizzare i dati del CSV
    function loadCSVData(text) {
      const data = parseCSV(text);

      const points = [];
      const colors = [];
      const sizes = [];

      // Trova i valori min/max di Z per normalizzare i colori
      const zValues = data.map(d => parseFloat(d.Z));
      const minZ = Math.min(...zValues);
      const maxZ = Math.max(...zValues);

      // Aggiungi punti alla geometria
      data.forEach(d => {
        const x = parseFloat(d.X);
        const y = parseFloat(d.Y);
        const z = parseFloat(d.Z);
        const md = parseFloat(d.MD);

        points.push(x, y, z);

        // Colore basato su Z
        const normalizedZ = (z - minZ) / (maxZ - minZ);
        const color = new THREE.Color();
        color.setHSL(normalizedZ * 0.8, 1.0, 0.5); // Gradiente da blu a rosso
        colors.push(color.r, color.g, color.b);

        // Dimensione proporzionale a MD
        sizes.push(md * 10); // Scala della dimensione
      });

      // Crea una geometria buffer
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

      // Materiale della point cloud
      const material = new THREE.PointsMaterial({
        size: 10,
        vertexColors: true,
        sizeAttenuation: true,
      });

      // Crea la point cloud e aggiungila alla scena
      const pointCloud = new THREE.Points(geometry, material);
      scene.add(pointCloud);
    }

    // Funzione per il parsing del CSV
    function parseCSV(data) {
      const lines = data.split('\n').filter(line => line.trim() !== '');
      const headers = lines[0].split(',');
      return lines.slice(1).map(line => {
        const values = line.split(',');
        const obj = {};
        headers.forEach((header, index) => {
          obj[header] = values[index];
        });
        return obj;
      });
    }

    // Animazione
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // Adatta il renderer quando la finestra cambia dimensione
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
