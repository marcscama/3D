<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<title>Gossip-INGV-Terremoti dal 2005 al 07/2025 con MD > 0</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  html,body { margin:0; padding:0; width:100%; height:100%; background:#000; overflow:hidden; }
  #tooltip {
    position: absolute;
    padding: 6px 10px;
    background: rgba(0,0,0,0.8);
    color: white;
    font-family: sans-serif;
    font-size: 13px;
    border-radius: 6px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.15s;
  }
</style>
</head>
<body>
  <div id="tooltip"></div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/"
    }
  }
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.19.1/proj4.js"></script>

  <script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

  (async () => {
    const CSV_URL = 'https://marcscama.github.io/3D/Terremoti-Gossip-2005-07-2025.csv';
    const CRS_SRC = 'EPSG:4326', CRS_DST = 'EPSG:3857';
    const tooltip = document.getElementById('tooltip');

    // Sfondo gradiente (corretto: da grigio scuro in basso a grigio chiaro in alto)
    function createGradientTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 1;
      canvas.height = 256;
      const ctx = canvas.getContext('2d');
      const gradient = ctx.createLinearGradient(0,0,0,256);
      gradient.addColorStop(0, '#404040'); // grigio scuro in alto
      gradient.addColorStop(1, '#d0d0d0'); // grigio chiaro in basso
      ctx.fillStyle = gradient;
      ctx.fillRect(0,0,1,256);
      const texture = new THREE.CanvasTexture(canvas);
      texture.magFilter = THREE.LinearFilter;
      texture.minFilter = THREE.LinearFilter;
      return texture;
    }

    // Scena
    const scene = new THREE.Scene();
    scene.background = createGradientTexture();

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1e12);
    camera.up.set(0,0,1);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Luci
    const ambient = new THREE.AmbientLight(0xffffff, 0.1);
    scene.add(ambient);
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    scene.add(dirLight);
    scene.add(dirLight.target);

    const sphereGroup = new THREE.Group();
    scene.add(sphereGroup);

    function parseCSV(text) {
      const lines = text.split(/\r?\n/).filter(l => l.trim());
      const headerIdx = lines.findIndex(l => l.startsWith('Longitude,Latitude,Depth,MD,Time'));
      if (headerIdx < 0) throw new Error('Header CSV non trovato');
      const header = lines[headerIdx].split(',').map(h => h.trim());
      const rows = [];
      for (let i = headerIdx + 1; i < lines.length; i++) {
        const cols = lines[i].split(',').map(c => c.trim());
        if (cols.length < header.length) continue;
        const obj = {};
        header.forEach((h, idx) => obj[h] = cols[idx]);
        rows.push(obj);
      }
      return rows;
    }

    try {
      const resp = await fetch(CSV_URL);
      if (!resp.ok) throw new Error('Fetch fallito: ' + resp.status);
      const rows = parseCSV(await resp.text());

      const pts = rows.map(r => {
        const lon = parseFloat(r.Longitude), lat = parseFloat(r.Latitude);
        const depth = parseFloat(r.Depth);
        const z = Number.isFinite(depth) ? depth * -1000 : NaN;
        const md = parseFloat(r.MD);
        return { lon, lat, z, md, time: r.Time };
      }).filter(p => Number.isFinite(p.lon) && Number.isFinite(p.lat) && Number.isFinite(p.z) && Number.isFinite(p.md));

      const coords = new Float64Array(pts.length * 3);
      for (let i = 0; i < pts.length; i++) {
        const [x, y] = proj4(CRS_SRC, CRS_DST, [pts[i].lon, pts[i].lat]);
        coords[i*3] = x;
        coords[i*3+1] = y;
        coords[i*3+2] = pts[i].z;
      }

      const bbox = new THREE.Box3();
      for (let i = 0; i < pts.length; i++) {
        bbox.expandByPoint(new THREE.Vector3(coords[i*3], coords[i*3+1], coords[i*3+2]));
      }
      const center = bbox.getCenter(new THREE.Vector3());
      const sizeLen = bbox.getSize(new THREE.Vector3()).length();
      const scaleFactor = Math.max(1, sizeLen * 0.00035);

      const zvals = [];
      for (let i = 0; i < pts.length; i++) zvals.push(coords[i*3+2]);
      const zmin = Math.min(...zvals), zmax = Math.max(...zvals);

      function zToRainbow(z) {
        const t = (z - zmin) / (zmax - zmin || 1);
        const hue = (1 - t) * 300;
        const c = new THREE.Color();
        c.setHSL((hue % 360) / 360, 0.95, THREE.MathUtils.clamp(0.65 - 0.3 * t, 0.2, 0.8));
        return c;
      }

      const sphereMinRadius = Math.max(0.7, scaleFactor * 0.0012);
      const sphereMaxRadius = Math.max(350, scaleFactor * 0.20);

      for (let i = 0; i < pts.length; i++) {
        let r = Math.pow(pts[i].md, 2) * scaleFactor;
        r = Math.min(Math.max(r, sphereMinRadius), sphereMaxRadius);
        const color = zToRainbow(coords[i*3+2]);
        const mat = new THREE.MeshPhongMaterial({
          color,
          specular: new THREE.Color(0xffffff),
          shininess: 180,
          emissive: color.clone().multiplyScalar(0.10),
          emissiveIntensity: 0.7
        });
        const geom = new THREE.SphereGeometry(r, 32, 24);
        const mesh = new THREE.Mesh(geom, mat);
        mesh.position.set(coords[i*3] - center.x, coords[i*3+1] - center.y, coords[i*3+2] - center.z);
        mesh.userData = { time: pts[i].time, md: pts[i].md, z: pts[i].z };
        sphereGroup.add(mesh);
      }
      sphereGroup.position.copy(center);

      const dist = Math.max(sizeLen * 0.8, 3000);
      camera.position.set(center.x + dist*0.6, center.y + dist*0.25, center.z + dist*0.55);
      camera.near = Math.max(0.1, dist * 0.00001);
      camera.far = Math.max(1e9, dist * 300, sizeLen * 300);
      camera.updateProjectionMatrix();
      controls.target.copy(center);
      controls.update();

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Tooltip on click
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      window.addEventListener('click', (event) => {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(sphereGroup.children);
        if (intersects.length > 0) {
          const data = intersects[0].object.userData;
          tooltip.innerHTML = `Data: ${data.time}<br>MD: ${data.md}<br>Profondit√†: ${data.z} m`;
          tooltip.style.left = `${event.clientX + 10}px`;
          tooltip.style.top = `${event.clientY + 10}px`;
          tooltip.style.opacity = 1;
        } else {
          tooltip.style.opacity = 0;
        }
      });

      const rotationSpeed = 0.0015;
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        dirLight.position.copy(camera.position);
        const camDir = new THREE.Vector3();
        camera.getWorldDirection(camDir);
        dirLight.target.position.copy(camera.position.clone().add(camDir.multiplyScalar(1000)));
        dirLight.target.updateMatrixWorld();
        sphereGroup.rotation.z += rotationSpeed;
        renderer.render(scene, camera);
      }
      animate();

    } catch (err) {
      console.error(err);
    }
  })();
  </script>
</body>
</html>
