<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <title>Flegrei — Three.js (latest import via Skypack)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body{height:100%;margin:0;background:#000;color:#fff;font-family:system-ui,Segoe UI,Roboto,Arial}
    canvas{display:block;width:100%;height:100%}
    #status{position:absolute;left:8px;top:8px;z-index:1000;padding:6px 10px;border-radius:6px;background:rgba(0,0,0,0.6);pointer-events:none}
  </style>
</head>
<body>
  <div id="status">Loading CSV...</div>
  <canvas id="canvas"></canvas>

  <!-- proj4 + PapaParse as globals -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js"></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

  <script type="module">
    // IMPORT THREE.js ESM from Skypack (serves modern/latest ESM)
    import * as THREE from 'https://cdn.skypack.dev/three@latest';
    import { OrbitControls } from 'https://cdn.skypack.dev/three@latest/examples/jsm/controls/OrbitControls.js';

    const CSV_URL = 'https://api.cors.lol/?url=https://terremoti.ov.ingv.it/gossip/flegrei/events.csv';
    const statusEl = document.getElementById('status');
    function setStatus(msg, err=false){ statusEl.textContent = msg; statusEl.style.background = err ? 'rgba(128,0,0,0.8)' : 'rgba(0,0,0,0.6)'; }

    // Three.js setup
    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a0a);
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1e9);
    camera.position.set(0, -20000, 10000);
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.dampingFactor = 0.08;
    window.addEventListener('resize', ()=>{ camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

    let pointsMesh = null;

    // helpers (same as before)
    function hsvToRgb(h,s,v){
      let r,g,b; const i=Math.floor(h*6); const f=h*6-i; const p=v*(1-s); const q=v*(1-f*s); const t=v*(1-(1-f)*s);
      switch(i%6){ case 0: r=v; g=t; b=p; break; case 1: r=q; g=v; b=p; break; case 2: r=p; g=v; b=t; break; case 3: r=p; g=q; b=v; break; case 4: r=t; g=p; b=v; break; default: r=v; g=p; b=q; break; }
      return [r,g,b];
    }
    function mapZtoColors(zArr){
      let zmin=Infinity,zmax=-Infinity; for (let z of zArr){ if (z<zmin) zmin=z; if (z>zmax) zmax=z; }
      const n = zArr.length; const out = new Float32Array(n*3);
      for (let i=0;i<n;i++){ const t = (zmax===zmin)?0.5:((zArr[i]-zmin)/(zmax-zmin)); const hue=(1.0-t)*0.8; const c=hsvToRgb(hue,1,1); out[i*3]=c[0]; out[i*3+1]=c[1]; out[i*3+2]=c[2];}
      return out;
    }
    function mapMDToSizes(mdArr,minPx=2,maxPx=28){
      const n = mdArr.length; const md4 = new Float64Array(n); let mn=Infinity,mx=-Infinity;
      for (let i=0;i<n;i++){ const v=Number(mdArr[i]); const v4=Math.pow(v,4); md4[i]=v4; if(v4<mn)mn=v4; if(v4>mx)mx=v4; }
      const s = new Float32Array(n);
      for (let i=0;i<n;i++){ const t=(mx===mn)?0.5:((md4[i]-mn)/(mx-mn)); s[i]=minPx + t*(maxPx-minPx); }
      return s;
    }

    function createPoints(positions, colors, sizes){
      if (pointsMesh){ scene.remove(pointsMesh); pointsMesh.geometry.dispose(); pointsMesh.material.dispose(); pointsMesh=null; }
      const geom = new THREE.BufferGeometry();
      geom.setAttribute('position', new THREE.BufferAttribute(positions,3));
      geom.setAttribute('color', new THREE.BufferAttribute(colors,3));
      geom.setAttribute('size', new THREE.BufferAttribute(sizes,1));
      geom.computeBoundingSphere();

      const mat = new THREE.ShaderMaterial({
        vertexColors: true,
        uniforms: { scale: { value: window.innerHeight/2.0 } },
        vertexShader: `
          attribute float size;
          varying vec3 vColor;
          uniform float scale;
          void main(){
            vColor = color;
            vec4 mv = modelViewMatrix * vec4(position,1.0);
            gl_PointSize = size * (scale / -mv.z);
            gl_Position = projectionMatrix * mv;
          }
        `,
        fragmentShader: `
          varying vec3 vColor;
          void main(){
            vec2 c = gl_PointCoord - vec2(0.5);
            if (dot(c,c) > 0.25) discard;
            gl_FragColor = vec4(vColor, 1.0);
          }
        `,
        transparent:true, depthTest:true
      });

      const pts = new THREE.Points(geom, mat);
      pts.frustumCulled = false;
      scene.add(pts);
      pointsMesh = pts;

      // fit camera
      const bs = geom.boundingSphere;
      if (bs){ controls.target.copy(bs.center); controls.update(); const r=bs.radius; camera.position.set(bs.center.x, bs.center.y - r*2.2, bs.center.z + r*1.2); camera.lookAt(bs.center); }
    }

    // parse CSV block and process
    function extractParseCSV(text){
      const lines = text.split(/\r?\n/);
      let start=-1;
      for (let i=0;i<lines.length;i++){ if (lines[i].startsWith('#EventID')||lines[i].startsWith('EventID')){ start=i; break; } }
      const csvText = (start>=0) ? [lines[start].replace(/^#/,'')].concat(lines.slice(start+1)).join('\n') : text;
      const parsed = Papa.parse(csvText, { header:true, skipEmptyLines:true });
      if (parsed.errors && parsed.errors.length) console.warn('PapaParse errors', parsed.errors.slice(0,5));
      return parsed.data;
    }

    function lonLatToMerc(lons,lats){
      const n=lons.length; const out = new Float32Array(n*2);
      for (let i=0;i<n;i++){ const xy = proj4('EPSG:4326','EPSG:3857',[Number(lons[i]), Number(lats[i])]); out[i*2]=xy[0]; out[i*2+1]=xy[1]; }
      return out;
    }

    function processRows(rows){
      const lons=[], lats=[], depths=[], mds=[];
      for (const r of rows){
        const MD = Number(r['MD'] ?? r['Md'] ?? r['md']);
        if (!(MD > 0)) continue;
        const Lon = r['Longitude'] ?? r['Lon'] ?? r['lon']; const Lat = r['Latitude'] ?? r['Lat'] ?? r['lat']; const Depth = r['Depth'] ?? r['depth'] ?? r['DEPTH'];
        if (Lon===undefined||Lat===undefined||Depth===undefined) continue;
        const lon=Number(Lon), lat=Number(Lat), depth=Number(Depth);
        if (!isFinite(lon)||!isFinite(lat)||!isFinite(depth)) continue;
        lons.push(lon); lats.push(lat); depths.push(depth); mds.push(MD);
      }
      if (mds.length===0){ setStatus('Nessun record MD>0', true); return; }
      setStatus(`Records: ${mds.length} — convertendo...`);
      const merc = lonLatToMerc(lons,lats);
      const n = mds.length; const pos = new Float32Array(n*3); const zArr = new Float32Array(n);
      for (let i=0;i<n;i++){ pos[i*3]=merc[i*2]; pos[i*3+1]=merc[i*2+1]; pos[i*3+2] = -depths[i]*1000.0; zArr[i]=pos[i*3+2]; }
      const colors = mapZtoColors(zArr); const sizes = mapMDToSizes(mds, 2, 28);
      setStatus('Rendering...');
      createPoints(pos, colors, sizes);
      setStatus(`Visualizzati ${n} punti (MD>0)`);
    }

    // load CSV via proxy then process
    async function loadCSV(){
      try {
        setStatus('Scaricamento CSV (proxy)...');
        const res = await fetch(CSV_URL, { mode:'cors' });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const txt = await res.text();
        setStatus('CSV ricevuto — parsing...');
        const rows = extractParseCSV(txt);
        processRows(rows);
      } catch (err){
        console.error(err);
        setStatus('Errore: ' + (err.message || err), true);
      }
    }

    // animation
    (function anim(){ requestAnimationFrame(anim); controls.update(); renderer.render(scene, camera); })();

    // start
    setStatus('Init — caricamento CSV...');
    loadCSV();

    // expose DEBUG info if needed
    console.log('Three import via Skypack — THREE keys:', Object.keys(THREE).slice(0,20));
  </script>
</body>
</html>
